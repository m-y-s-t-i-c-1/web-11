<!DOCTYPE html>
<html lang="ro">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Algoritmi pe grafuri 칥n C++</title>
  <link rel="stylesheet" href="/Proiect pa programare web/surse code/stilizareC++.css">
</head>

<body>

  <h1>游빑 Algoritmi pe grafuri 칥n C++</h1>

  <div class="section">
    <h2>游댳 Reprezentarea unui graf</h2>
    <p>Un graf poate fi reprezentat folosind o matrice de adiacen탵캒 sau o list캒 de adiacen탵캒. Vom folosi matricea de
      adiacen탵캒 pentru acest exemplu.</p>
    <pre><code>const int MAX_N = 100;
int graf[MAX_N][MAX_N]; // matrice de adiacen탵캒</code></pre>
  </div>

  <div class="section">
    <h2>游댳 Algoritmul DFS (Depth-First Search)</h2>
    <p>DFS parcurge graful 칥n ad칙ncime, explor칙nd c칙t mai mult posibil de la un nod 칥nainte de a face un backtrack.</p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;stack&gt;
using namespace std;

void dfs(int graf[MAX_N][MAX_N], int n, int start) {
    bool vizitat[MAX_N] = {false};
    stack&lt;int&gt; stiva;
    stiva.push(start);
    vizitat[start] = true;

    while (!stiva.empty()) {
        int nod = stiva.top();
        stiva.pop();
        cout &lt;&lt; nod &lt;&lt; " ";

        for (int i = 0; i &lt; n; i++) {
            if (graf[nod][i] == 1 && !vizitat[i]) {
                stiva.push(i);
                vizitat[i] = true;
            }
        }
    }
}</code></pre>
  </div>

  <div class="section">
    <h2>游댳 Algoritmul BFS (Breadth-First Search)</h2>
    <p>BFS exploreaz캒 graful 칥n l캒탵ime, vizit칙nd to탵i vecinii unui nod 칥nainte de a trece la urm캒torul nivel.</p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

void bfs(int graf[MAX_N][MAX_N], int n, int start) {
    bool vizitat[MAX_N] = {false};
    queue&lt;int&gt; coada;
    coada.push(start);
    vizitat[start] = true;

    while (!coada.empty()) {
        int nod = coada.front();
        coada.pop();
        cout &lt;&lt; nod &lt;&lt; " ";

        for (int i = 0; i &lt; n; i++) {
            if (graf[nod][i] == 1 && !vizitat[i]) {
                coada.push(i);
                vizitat[i] = true;
            }
        }
    }
}</code></pre>
  </div>

  <div class="section">
    <h2>游댳 Exerci탵iu: Implementare DFS 탳i BFS</h2>
    <p>Implementeaz캒 un program care cite탳te un graf neorientat din fi탳ier 탳i aplic캒 at칙t DFS c칙t 탳i BFS.</p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
using namespace std;

int graf[MAX_N][MAX_N];

void dfs(int n, int start) {
    bool vizitat[MAX_N] = {false};
    stack&lt;int&gt; stiva;
    stiva.push(start);
    vizitat[start] = true;

    while (!stiva.empty()) {
        int nod = stiva.top();
        stiva.pop();
        cout &lt;&lt; nod &lt;&lt; " ";

        for (int i = 0; i &lt; n; i++) {
            if (graf[nod][i] == 1 && !vizitat[i]) {
                stiva.push(i);
                vizitat[i] = true;
            }
        }
    }
}

void bfs(int n, int start) {
    bool vizitat[MAX_N] = {false};
    queue&lt;int&gt; coada;
    coada.push(start);
    vizitat[start] = true;

    while (!coada.empty()) {
        int nod = coada.front();
        coada.pop();
        cout &lt;&lt; nod &lt;&lt; " ";

        for (int i = 0; i &lt; n; i++) {
            if (graf[nod][i] == 1 && !vizitat[i]) {
                coada.push(i);
                vizitat[i] = true;
            }
        }
    }
}

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m; // num캒rul de noduri 탳i muchii

    // Ini탵ializare matrice de adiacen탵캒
    for (int i = 0; i &lt; m; i++) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        graf[u][v] = 1;
        graf[v][u] = 1; // graf neorientat
    }

    cout &lt;&lt; "DFS: ";
    dfs(n, 0); // pornire de la nodul 0
    cout &lt;&lt; endl;

    cout &lt;&lt; "BFS: ";
    bfs(n, 0); // pornire de la nodul 0
    cout &lt;&lt; endl;

    return 0;
}</code></pre>
  </div>

  <div class="section">
    <h2>游댳 Concluzie</h2>
    <ul>
      <li><strong>DFS</strong> folose탳te stiva pentru a parcurge graful 칥n ad칙ncime.</li>
      <li><strong>BFS</strong> folose탳te coada pentru a parcurge graful 칥n l캒탵ime.</li>
      <li>Reprezentarea grafului cu matrice de adiacen탵캒 este simpl캒, dar consum캒 mult캒 memorie pentru grafuri mari.
      </li>
    </ul>
  </div>

  <div class="navigatie">
    <a class="stanga" href="../c++/algoritmi de sortare,cautare.html">&#8592; 칉napoi</a>
    <a class="dreapta" href="../c++/alocarea dinamica.html">칉nainte &#8594;</a>
  </div>

</body>

</html>