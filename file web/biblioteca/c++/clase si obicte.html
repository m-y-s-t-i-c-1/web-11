<!DOCTYPE html>
<html lang="ro">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Clase 탳i Obiecte 칥n C++ - Programare Orientat캒 pe Obiecte</title>
  <link rel="stylesheet" href="/Proiect pa programare web/surse code/stilizareC++.css">
</head>

<body>

  <h1>游댢 Clase 탳i Obiecte 칥n C++ - Programare Orientat캒 pe Obiecte (OOP)</h1>

  <div class="section">
    <h2>游댳 Ce este o clas캒?</h2>
    <p>O clas캒 este un tip de date definit de utilizator care combin캒 datele (atribute) 탳i func탵iile (metodele) care
      opereaz캒 asupra acestor date. Este fundamentul program캒rii orientate pe obiecte (OOP).</p>
  </div>

  <div class="section">
    <h2>游댳 Definirea unei clase</h2>
    <p>칉n C++, o clas캒 este definit캒 cu ajutorul cuv칙ntului cheie <code>class</code>.</p>
    <pre><code>class Persoana {
public:
    string nume;
    int varsta;

    // Constructor
    Persoana(string n, int v) : nume(n), varsta(v) {}

    // Metod캒
    void afisare() {
        cout &lt;&lt; "Nume: " &lt;&lt; nume &lt;&lt; ", Varsta: " &lt;&lt; varsta &lt;&lt; endl;
    }
};</code></pre>
  </div>

  <div class="section">
    <h2>游댳 Crearea unui obiect</h2>
    <p>Un obiect este o instan탵캒 a unei clase. Dup캒 ce ai definit o clas캒, po탵i crea obiecte ale acelei clase.</p>
    <pre><code>int main() {
    Persoana p1("Ion", 20);  // creaz캒 un obiect de tip Persoana
    p1.afisare();  // apel캒m metoda afisare
    return 0;
}</code></pre>
  </div>

  <div class="section">
    <h2>游댳 Constructori 탳i Destructori</h2>
    <p>Constructorul este o func탵ie special캒 care este apelat캒 automat atunci c칙nd se creeaz캒 un obiect. Destructorul
      este apelat atunci c칙nd obiectul este distrus.</p>

    <h3>Constructori</h3>
    <p>Constructorii pot fi defini탵i pentru a ini탵ializa obiectele la crearea lor. Exist캒 constructori implicit 탳i
      parametriza탵i.</p>
    <pre><code>class Persoana {
public:
    string nume;
    int varsta;

    // Constructor parametrizat
    Persoana(string n, int v) : nume(n), varsta(v) {}

    // Constructor implicit
    Persoana() : nume("Necunoscut"), varsta(0) {}

    void afisare() {
        cout &lt;&lt; "Nume: " &lt;&lt; nume &lt;&lt; ", Varsta: " &lt;&lt; varsta &lt;&lt; endl;
    }
};</code></pre>

    <h3>Destructori</h3>
    <p>Destructorii sunt utiliza탵i pentru a cur캒탵a resursele atunci c칙nd obiectul este distrus.</p>
    <pre><code>~Persoana() {
    cout &lt;&lt; "Obiectul a fost distrus." &lt;&lt; endl;
}</code></pre>
  </div>

  <div class="section">
    <h2>游댳 Modificatori de acces: public, private, protected</h2>
    <p>Aceste modificatoare definesc accesibilitatea atributelor 탳i metodelor dintr-o clas캒:</p>
    <ul>
      <li><code>public</code>: Membrii sunt accesibili din afacerea clasei.</li>
      <li><code>private</code>: Membrii sunt accesibili doar din interiorul clasei.</li>
      <li><code>protected</code>: Membrii sunt accesibili din interiorul clasei 탳i al claselor derivate (칥n mo탳tenire).
      </li>
    </ul>
    <pre><code>class Persoana {
private:
    string nume;
    int varsta;

public:
    void setNume(string n) {
        nume = n;
    }

    string getNume() {
        return nume;
    }
};</code></pre>
  </div>

  <div class="section">
    <h2>游댳 Supraincarcarea operatorilor</h2>
    <p>칉n C++, putem supraincarca operatorii pentru a le da un comportament personalizat.</p>
    <pre><code>class Complex {
public:
    int real, imaginar;

    Complex(int r = 0, int i = 0) : real(r), imaginar(i) {}

    // Supraincarcarea operatorului +
    Complex operator + (const Complex& c) {
        return Complex(real + c.real, imaginar + c.imaginar);
    }

    void afisare() {
        cout &lt;&lt; real &lt;&lt; " + " &lt;&lt; imaginar &lt;&lt; "i" &lt;&lt; endl;
    }
};

int main() {
    Complex c1(1, 2), c2(3, 4);
    Complex c3 = c1 + c2;  // folosirea operatorului +
    c3.afisare();
    return 0;
}</code></pre>
  </div>

  <div class="section">
    <h2>游댳 Mo탳tenirea</h2>
    <p>Mo탳tenirea permite crearea de noi clase pe baza unor clase existente. Clasa derivat캒 mo탳tene탳te atributele 탳i
      metodele clasei de baz캒.</p>
    <pre><code>class Animal {
public:
    void mananca() {
        cout &lt;&lt; "Animalul mananca." &lt;&lt; endl;
    }
};

class Caine : public Animal {
public:
    void latra() {
        cout &lt;&lt; "Cainele latra." &lt;&lt; endl;
    }
};

int main() {
    Caine c;
    c.mananca();  // metoda mo탳tenit캒 din Animal
    c.latra();    // metoda specific캒 clasei Caine
    return 0;
}</code></pre>
  </div>

  <div class="section">
    <h2>游댳 Polimorfismul</h2>
    <p>Polimorfismul permite ca acelea탳i func탵ii s캒 se comporte diferit pe obiecte de tipuri diferite.</p>
    <pre><code>class Forma {
public:
    virtual void desen() {
        cout &lt;&lt; "Desen캒m o form캒." &lt;&lt; endl;
    }
};

class Cerc : public Forma {
public:
    void desen() override {
        cout &lt;&lt; "Desen캒m un cerc." &lt;&lt; endl;
    }
};

int main() {
    Forma* f = new Cerc();
    f-&gt;desen();  // va apela metoda desen() din Cerc
    delete f;
    return 0;
}</code></pre>
  </div>

  <div class="section">
    <h2>游댳 Exemplu complet: Clas캒 탳i mo탳tenire</h2>
    <pre><code>#include &lt;iostream&gt;
using namespace std;

class Vehicul {
public:
    virtual void descriere() {
        cout &lt;&lt; "Este un vehicul." &lt;&lt; endl;
    }
};

class Masina : public Vehicul {
public:
    void descriere() override {
        cout &lt;&lt; "Este o masina." &lt;&lt; endl;
    }
};

int main() {
    Vehicul* v = new Masina();
    v-&gt;descriere();
    delete v;
    return 0;
}</code></pre>
  </div>

  <div class="navigatie">
    <a class="stanga" href="../c++/alocarea dinamica.html">&#8592; 칉napoi</a>
  </div>

</body>

</html>